[
  {
    "front": "ðŸ§© Bisection Method\nðŸ“˜ Domain: Numerical Optimization / Line Search",
    "back": "**Definition:** A robust bracketing method that locates a root of a continuous function $\\phi(\\alpha)$ by repeatedly halving an interval $[a, b]$ where $\\phi(a) \\le 0 \\le \\phi(b)$ (or vice versa) until the interval length is below a tolerance.\n\n**Description:** Used in line search to find a step length $\\alpha_k > 0$ satisfying the Wolfe conditions. Converges **linearly** with rate $C = \\frac{1}{2}$ because the uncertainty interval is halved at each iteration.\n\n**Goal:** Find $\\alpha_k$ such that $\\phi(\\alpha_k) \\le \\phi(0) + c_1 \\alpha_k \\phi'(0)$ and $|\\phi'(\\alpha_k)| \\le c_2 |\\phi'(0)|$ (Wolfe conditions).\n**Applications:** Exact line search fallback, Backtracking line search when Armijo fails\n**Methods:** Initialize bracket $[\\alpha_{\\text{low}}, \\alpha_{\\text{high}}]$ with opposite signs or satisfying bounds, Set midpoint $\\alpha_{\\text{mid}} = \\frac{\\alpha_{\\text{low}} + \\alpha_{\\text{high}}}{2}$, Shrink interval based on $\\phi(\\alpha_{\\text{mid}})$ sign or Wolfe violation\n**Examples:** Solving $\\phi'(\\alpha) = \\alpha^5 - \\alpha - 1 = 0$ in $[1, 2]$"
  },
  {
    "front": "ðŸ§© Least Squares Problems\nðŸ“˜ Domain: Unconstrained Optimization",
    "back": "**Definition:** Minimize $f(x) = \\frac{1}{2} \\| r(x) \\|^2 = \\frac{1}{2} \\sum_{j=1}^m r_j(x)^2$, where $r: \\mathbb{R}^n \\to \\mathbb{R}^m$ is the vector of **residual functions** $r_j(x)$.\n\n**Description:** Arises when overdetermined systems $r_j(x) = 0$ ($m \\ge n$) have no exact solution. Transforms root-finding into minimization. Special structure: $\\nabla f(x) = J(x)^T r(x)$, $\\nabla^2 f(x) = J(x)^T J(x) + \\sum r_j(x) \\nabla^2 r_j(x)$.\n\n**Goal:** Find best-fit parameters $x^*$ minimizing sum of squared residuals.\n**Applications:** Data fitting, Machine learning (regression), Parameter estimation\n**Methods:** Gaussâ€“Newton (ignores second-order residual terms), Levenbergâ€“Marquardt (adds damping), Full Newton (uses exact Hessian)\n**Examples:** Linear regression: $r_j(x) = a_j^T x - b_j$"
  },
  {
    "front": "ðŸ§© Linear Least Squares Problem (Linear Regression)\nðŸ“˜ Domain: Linear Algebra / Regression",
    "back": "**Definition:** Minimize $f(x) = \\frac{1}{2} \\| A x - b \\|^2$, where $A \\in \\mathbb{R}^{m \\times n}$, $b \\in \\mathbb{R}^m$, $m \\ge n$.\n\n**Description:** Closed-form solution via **normal equations**: $A^T A x = A^T b$. Numerically stable via **QR factorization**: $A = QR$, solve $R x = Q^T b$.\n\n**Goal:** Find $x^*$ minimizing $\\sum (a_j^T x - b_j)^2$.\n**Applications:** Linear regression, Polynomial fitting\n**Methods:** Normal equations (if $A^T A$ well-conditioned), QR decomposition (preferred), SVD (for rank-deficient cases)\n**Examples:** Fit $y = x_1 + x_2 t$: residuals $r_j = x_1 + x_2 t_j - y_j$"
  },
  {
    "front": "ðŸ§© Gaussâ€“Newton Method\nðŸ“˜ Domain: Nonlinear Least Squares",
    "back": "**Definition:** Iterative method for nonlinear least squares: at $x_k$, solve $J_k^T J_k p_k = -J_k^T r_k$ for step $p_k$, where $J_k = J(x_k)$ is the Jacobian of $r$.\n\n**Description:** Approximates Hessian as $B_k = J_k^T J_k$, neglecting $\\sum r_j \\nabla^2 r_j$. Valid when residuals are small at solution. Step satisfies $p_k^T \\nabla f_k = -\\| J_k p_k \\|^2 \\le 0$ (descent unless $J_k p_k = 0$).\n\n**Goal:** Efficiently solve nonlinear least squares without computing second derivatives.\n**Applications:** Curve fitting, Nonlinear regression\n**Methods:** Compute $J_k$, $r_k$, Solve $(J_k^T J_k) p_k = -J_k^T r_k$ (via QR/Cholesky), Line search: $x_{k+1} = x_k + \\alpha_k p_k$\n**Examples:** "
  },
  {
    "front": "ðŸ§© Residual Functions ($r_j(x)$)\nðŸ“˜ Domain: Least Squares",
    "back": "**Definition:** Scalar functions $r_j: \\mathbb{R}^n \\to \\mathbb{R}$, $j=1,\\dots,m$, representing model misfit: $r_j(x) = \\text{model}_j(x) - \\text{data}_j$.\n\n**Description:** Stacked into vector $r(x) = [r_1(x), \\dots, r_m(x)]^T$. Objective: $f(x) = \\frac{1}{2} \\| r(x) \\|^2$. Gradient: $\\nabla f(x) = J(x)^T r(x)$, where $J(x) = \\nabla r(x)$ is $m \\times n$ Jacobian.\n\n**Goal:** Quantify error between model and observations.\n**Applications:** Define $f(x)$, $\\nabla f(x)$, $J(x)$\n**Methods:** \n**Examples:** Linear: $r_j(x) = a_j^T x - b_j$, Nonlinear: $r_j(x) = e^{x_1 t_j} + x_2 \\cos(x_3 t_j) - y_j$"
  },
  {
    "front": "ðŸ§© Levenbergâ€“Marquardt Method\nðŸ“˜ Domain: Nonlinear Least Squares",
    "back": "**Definition:** Trust-region method for nonlinear least squares: solve $\\min_{\\|p\\| \\le \\Delta_k} \\| J_k p + r_k \\|^2$ approximately by solving $(J_k^T J_k + \\mu_k I) p = -J_k^T r_k$, adjusting $\\mu_k > 0$ to control step size.\n\n**Description:** Combines Gaussâ€“Newton ($\\mu_k = 0$) and steepest descent ($\\mu_k \\to \\infty$). Robust when $J_k^T J_k$ is singular or residuals are large.\n\n**Goal:** Solve nonlinear least squares with global convergence.\n**Applications:** Curve fitting, Computer vision (bundle adjustment)\n**Methods:** Choose $\\mu_k$ via trust-region logic or heuristic, Solve damped normal equations, Update $\\Delta_k$ based on $\\rho_k$\n**Examples:** "
  },
  {
    "front": "ðŸ§© Duality Theory (Convex Optimization)\nðŸ“˜ Domain: Convex Optimization",
    "back": "**Definition:** A major concept in optimization focused on the relationship between a primal constrained minimization problem ($\\min~f(x)$ subject to $c(x)\\ge0$) and its corresponding dual problem.\n\n**Description:** Duality requires strong assumptions, namely that the objective function $f$ must be convex, and the constraint functions $c_{j}$ must be concave (meaning $-c_{j}$ are convex). This guarantees that the Lagrangian $\\mathcal{L}(x,\\lambda)$ is convex in $x$ for any fixed $\\lambda\\ge0$.\n\n**Goal:** Analyze and potentially solve constrained optimization problems using dual variables.\n**Applications:** Linear Programming (LP), Quadratic Programming (QP)\n**Methods:** Formulating the Lagrangian function $\\mathcal{L}(x,\\lambda)=f(x)-\\lambda^{T}c(x)$\n**Examples:** "
  },
  {
    "front": "ðŸ§© Dual Objective Function ($q(\\lambda)$)\nðŸ“˜ Domain: Duality Theory",
    "back": "**Definition:** The infimum of the Lagrangian function over $x$ for a fixed $\\lambda\\ge0$: $q(\\lambda)=\\inf_{x}\\mathcal{L}(x,\\lambda)$ (74).\n\n**Description:** This function is defined only for those $\\lambda\\ge0$ for which the infimum is finite ($q(\\lambda)> -\\infty$). The dual function $q$ is always concave (hence $-q$ is convex).\n\n**Goal:** Define the objective function for the Dual Problem (76).\n**Applications:** Formulating the Dual Problem (76)\n**Methods:** Finding critical points by setting $\\nabla_{x}\\mathcal{L}(x,\\lambda)=0$ (assuming smoothness)\n**Examples:** For $\\min\\frac{1}{2}(x_{1}^{2}+x_{2}^{2})$ subject to $x_{1}-1\\ge0$, $q(\\lambda)=-\\frac{1}{2}\\lambda^{2}+\\lambda$."
  },
  {
    "front": "ðŸ§© Dual Problem (76)\nðŸ“˜ Domain: Duality Theory",
    "back": "**Definition:** The optimization problem defined by maximizing the dual objective function $q(\\lambda)$ subject to the constraint $\\lambda\\ge0$: $\\max~q(\\lambda)$ subject to $\\lambda\\ge0$.\n\n**Description:** Solving the dual problem provides information on the original (primal) problem (73). Due to weak duality, the optimal value of (76) is less than or equal to the optimal value of the primal problem.\n\n**Goal:** Maximize $q(\\lambda)$ to find the best lower bound for the primal problem's optimal value.\n**Applications:** Solving the Dual LP (79)\n**Methods:** Solving the KKT conditions for $x$ once the optimal $\\lambda^*$ is found.\n**Examples:** "
  },
  {
    "front": "ðŸ§© Weak Duality\nðŸ“˜ Domain: Duality Theory",
    "back": "**Definition:** The theorem stating that for any feasible primal solution $x$ and any $\\lambda\\ge0$ such that $q(\\lambda)> -\\infty$, the dual objective function value is always less than or equal to the primal objective value: $q(\\lambda)\\le f(x)$.\n\n**Description:** This inequality holds because $c(x)\\ge0$ and $\\lambda\\ge0$ imply $-\\lambda^{T}c(x)\\le0$, so $\\mathcal{L}(x,\\lambda)\\le f(x)$ and thus $q(\\lambda)\\le f(x)$. Weak duality gives a lower bound on the primal optimal value.\n\n**Goal:** Provide a simple lower bound for the optimal value of the primal problem.\n**Applications:** Verifying optimality: if $q(\\lambda)=f(x)$ for feasible $x,\\lambda$, then $x$ and $\\lambda$ are optimal\n**Methods:** \n**Examples:** "
  },
  {
    "front": "ðŸ§© Strong Duality (Theorem 12.12)\nðŸ“˜ Domain: Duality Theory",
    "back": "**Definition:** The property that the optimal values of the primal problem $f(x^*)$ and the dual problem $q(\\lambda^*)$ are equal, i.e., $q(\\lambda^{*})=f(x^{*})$. Under convexity and a constraint qualification (e.g., Slater's condition), strong duality holds.\n\n**Description:** Theorem 12.12 states that if $x^{*}$ is a solution to the primal problem (73) and there exists $\\lambda^{*}$ such that $(x^{*},\\lambda^{*})$ satisfies the KKT conditions (under convexity assumptions), then $\\lambda^{*}$ solves the dual problem (76) and $f(x^*)=q(\\lambda^*)$.\n\n**Goal:** Confirm that a found pair $(x,\\lambda)$ is globally optimal for both the primal and dual problems.\n**Applications:** Solving optimization problems by finding $\\lambda^*$ first and then $x$\n**Methods:** Proof combines convexity of $\\mathcal{L}(x,\\lambda^{*})$ in $x$, KKT conditions, and weak duality\n**Examples:** In example (75), the value of both the primal and dual problems is $\\frac{1}{2}$."
  },
  {
    "front": "ðŸ§© Dual Linear Program (79)\nðŸ“˜ Domain: Linear Programming/Duality",
    "back": "**Definition:** The dual problem corresponding to the primal LP $\\min~c^{T}x$ subject to $Ax\\ge b$ ($Ax-b\\ge0$): $\\max~b^{T}\\lambda$ subject to $A^{T}\\lambda = c$ and $\\lambda\\ge0$.\n\n**Description:** The dual objective function $q(\\lambda)$ for this LP is $b^{T}\\lambda$ when the stationarity condition $A^{T}\\lambda = c$ holds (otherwise $q(\\lambda)=-\\infty$). This transformation is useful if the dual problem is easier to solve than the primal.\n\n**Goal:** Solve the primal LP (78) indirectly by solving the dual problem.\n**Applications:** Alternative solution method for LP problems\n**Methods:** If solved for $\\lambda^{*}$, use $\\lambda^{*}$ to simplify the KKT conditions for $x$\n**Examples:** "
  },
  {
    "front": "ðŸ§© Interior Point Methods\nðŸ“˜ Domain: Constrained Optimization",
    "back": "**Definition:** A class of algorithms designed to overcome the combinatorial difficulty associated with optimization problems having many inequality constraints.\n\n**Description:** These methods are typically required for Quadratic Programming (QP) problems where the inequality constraints lead to $2^{m}$ possible active sets, making direct application of active-set or corner-based methods impractical.\n\n**Goal:** Efficiently solve constrained optimization problems with numerous inequality constraints.\n**Applications:** Quadratic Programming (44)\n**Methods:** \n**Examples:** "
  },
  {
    "front": "ðŸ§© Simplex Method Worst-Case Complexity\nðŸ“˜ Domain: Linear Programming",
    "back": "**Definition:** The maximum theoretical number of vertices the Simplex method might have to visit in the worst case, given by the number of feasible basic solutions $\\binom{m}{n}$ (for $m$ constraints and $n$ variables in standard form with $m\\ge n$).\n\n**Description:** Although the worst-case scenario is exponential in $n$ (as illustrated by contrived examples like the Klee-Minty cube), the Simplex method is regarded as efficient in practice, typically requiring at most $2m$ to $3m$ pivots.\n\n**Goal:** Define the upper bound of computational effort required by the Simplex method in the worst case.\n**Applications:** \n**Methods:** \n**Examples:** For a problem with $m=6$ equality constraints and $n=2$ non-basic variables (i.e., $6$ choose $2$), there are $\\binom{6}{2}=15$ basic feasible solutions."
  },
  {
    "front": "ðŸ§© Unconstrained Optimization\nðŸ“˜ Domain: Optimization",
    "back": "**Definition:** A mathematical minimization problem that seeks to find $x \\in \\mathbb{R}^n$ minimizing $f(x)$ with no constraints, so the feasible region $\\Omega$ is the entire space $\\mathbb{R}^n$.\n\n**Description:** This structure notably simplifies the optimization problem because the feasible region is $\\mathbb{R}^{n}$. The solution relies primarily on advanced calculus techniques involving the gradient of $f$ and Taylor's theorem, requiring $f$ to be sufficiently smooth.\n\n**Goal:** Minimizing the objective function $f(x)$ over $x \\in \\mathbb{R}^{n}$\n**Applications:** \n**Methods:** Line Search Methods, Trust Region Methods, Application of Taylor's theorem"
  },
  {
    "front": "ðŸ§© Local Minimizer ($x^*$)\nðŸ“˜ Domain: Optimization",
    "back": "**Definition:** A point $x^{*}\\in\\mathbb{R}^{n}$ that is a global minimizer when restricted to some neighborhood of $x^{*}$ intersected with the feasible region $\\Omega$.\n\n**Description:** Algorithms typically find only local minimizers, which may provide a poor estimate of the global solution. However, in convex optimization problems, any local minimizer is guaranteed to be a global minimizer.\n\n**Goal:** Identify points satisfying $f(x^{*})\\le f(x)$ locally\n**Applications:** \n**Methods:** Checking First-Order Necessary Condition (FONC), Checking Second-Order Sufficient Conditions (SOSC)\n**Examples:** "
  },
  {
    "front": "ðŸ§© First-Order Necessary Condition (FONC)\nðŸ“˜ Domain: Unconstrained Optimization",
    "back": "**Definition:** A necessary condition that a local minimizer $x^{*}$ of a smooth function $f$ must satisfy, requiring that the gradient vanishes: $\\nabla f(x^{*})=0$.\n\n**Description:** This condition is derived using Taylor's theorem (2.4) and means that the point $x^{*}$ is a stationary or critical point of $f$. If this condition is not met (i.e., $\\nabla f(x^{*})\\ne0$), the function must decrease when moving in the direction $-\\nabla f(x^{*})$.\n\n**Goal:** Identify stationary points that are candidates for minimizers\n**Applications:** Finding stationary points by solving the linear system $\\nabla f(x)=0$\n**Methods:** Application of Taylor's theorem (2.4)"
  },
  {
    "front": "ðŸ§© Positive Semidefinite Matrix\nðŸ“˜ Domain: Linear Algebra, Optimization",
    "back": "**Definition:** A symmetric matrix $A\\in\\mathbb{R}^{n\\times n}$ where all its eigenvalues are non-negative, which is mathematically equivalent to the condition $x^{T}Ax\\ge0$ for any vector $x$.\n\n**Description:** This matrix concept is crucial for the 'second derivative test' in optimization. For a stationary point to be a local minimizer, its Hessian matrix $\\nabla^{2}f(x^{*})$ must satisfy the positive semidefinite property, which forms the Second-Order Necessary Condition.\n\n**Goal:** Determine the curvature behavior (non-negative) of a function in all directions\n**Applications:** Defining Second-Order Necessary Condition (SONC)\n**Methods:** Checking eigenvalues\n**Examples:** "
  },
  {
    "front": "ðŸ§© Second-Order Sufficient Conditions (SOSC)\nðŸ“˜ Domain: Unconstrained Optimization",
    "back": "**Definition:** Conditions guaranteeing that a point $x^{*}$ is a strict local minimizer, requiring that $x^{*}$ is a stationary point ($\\nabla f(x^{*})=0$) and that the Hessian matrix $\\nabla^{2}f(x^{*})$ is positive definite.\n\n**Description:** Derived using Taylor's theorem (2.6), SOSC guarantees that $f$ increases in all directions when moving away from $x^{*}$, thereby confirming a strict local minimum. These conditions are sufficient but not necessary; for instance, $f(x)=x^4$ at $x=0$ is a local minimizer but fails the positive definiteness test.\n\n**Goal:** Confirm a strict local minimizer exists at a stationary point\n**Applications:** Higher-dimensional second derivative test\n**Methods:** Checking for positive definiteness of $\\nabla^{2}f(x^{*})$\n**Examples:** "
  },
  {
    "front": "ðŸ§© Saddle Point\nðŸ“˜ Domain: Optimization",
    "back": "**Definition:** A stationary point $x^*$ where the function $f$ grows in some directions and decreases in other directions when moving away from $x^{*}$.\n\n**Description:** Saddle points are critical points where the First-Order Necessary Condition (FONC) holds, but they are neither local minimizers nor maximizers, indicating mixed curvature in the Hessian.\n\n**Goal:** Classify stationary points that are not local minimizers.\n**Applications:** \n**Methods:** Checking the Hessian matrix $\\nabla^{2}f(x^{*})$ for positive and negative eigenvalues\n**Examples:** The point $(\\frac{-1}{\\sqrt{3}},0)$ for the function $f(x)=x_{1}(x_{1}^{2}-1)+x_{2}^{2}$"
  },
  {
    "front": "ðŸ§© Line Search Methods\nðŸ“˜ Domain: Unconstrained Optimization",
    "back": "**Definition:** A family of iterative methods used to solve unconstrained minimization problems by improving the current iterate $x_{k}$ in two sequential steps: choosing a descent direction $p_{k}$ and computing the optimal step length $\\alpha$.\n\n**Description:** The second step involves solving a one-dimensional subproblem, $min_{\\alpha>0}f(x_{k}+\\alpha p_{k})$, which finds the optimal distance to move in the chosen direction $p_k$. This subproblem is computationally simpler than the original $n$-dimensional problem.\n\n**Goal:** Iteratively find a local minimizer\n**Applications:** Solving unconstrained minimization problems\n**Methods:** Choosing $p_k$ (descent direction), Solving $min_{\\alpha>0}f(x_{k}+\\alpha p_{k})$ for $\\alpha$\n**Examples:** "
  },
  {
    "front": "ðŸ§© Descent Direction ($p_k$)\nðŸ“˜ Domain: Optimization, Line Search Methods",
    "back": "**Definition:** A direction $p_{k}$ chosen in a Line Search Method such that the objective function $f$ decreases when moving from the current iterate $x_{k}$ into that direction.\n\n**Description:** Choosing $p_k$ is the first step in Line Search Methods and must precede the determination of the step length $\\alpha$. Since $f$ must decrease, the computed step length $\\alpha$ must be positive.\n\n**Goal:** Ensure that the iteration $x_{k+1}$ results in a lower function value than $f(x_k)$\n**Applications:** Used in the first step of Line Search Methods\n**Methods:** Cleverly computing $p_k$"
  },
  {
    "front": "ðŸ§© Constrained Optimization Problem\nðŸ“˜ Domain: Optimization Theory",
    "back": "**Definition:** Minimize an objective function $f(x)$ subject to equality constraints $c_i(x) = 0$ for $i \\in \\mathcal{E}$ and inequality constraints $c_i(x) \\ge 0$ for $i \\in \\mathcal{I}$, defining the feasible set $\\Omega = \\{x \\in \\mathbb{R}^n \\mid c_i(x) = 0, \\, i \\in \\mathcal{E}; \\, c_i(x) \\ge 0, \\, i \\in \\mathcal{I}\\}$.\n\n**Description:** Extends unconstrained optimization by restricting the search to $\\Omega$. Most algorithms find only **local** minimizers within a neighborhood intersected with $\\Omega$.\n\n**Goal:** Find $x^* \\in \\Omega$ such that $f(x^*) \\le f(x)$ for all $x \\in \\Omega \\cap \\mathcal{N}(x^*)$ (local minimizer).\n**Applications:** Engineering design, Economics, Machine learning (e.g., SVM, constrained regression)\n**Methods:** KKT conditions for stationarity, Active-set methods, Interior-point methods, Penalty/barrier methods\n**Examples:** $\\min x_1 + x_2$ s.t. $x_1^2 + x_2^2 = 2$ (equality), $\\min x_1 + x_2$ s.t. $2 - x_1^2 - x_2^2 \\ge 0$ (inequality), QP: $\\min \\frac{1}{2} x^T Q x - b^T x$ s.t. $C x \\le d$"
  },
  {
    "front": "ðŸ§© Karush-Kuhn-Tucker (KKT) Conditions\nðŸ“˜ Domain: Constrained Optimization Theory",
    "back": "**Definition:** For a local minimizer $x^* \\in \\Omega$ under a constraint qualification (e.g., LICQ), there exist $\\lambda^*_i$ (Lagrange multipliers) such that:\\n1. **Stationarity**: $\\nabla f(x^*) = \\sum_{i \\in \\mathcal{E} \\cup \\mathcal{I}} \\lambda^*_i \\nabla c_i(x^*)$\\\\\n2. **Primal feasibility**: $c_i(x^*) = 0$ ($i \\in \\mathcal{E}$), $c_i(x^*) \\ge 0$ ($i \\in \\mathcal{I}$)$\\\\\n3. **Dual feasibility**: $\\lambda^*_i \\ge 0$ ($i \\in \\mathcal{I}$)$\\\\\n4. **Complementary slackness**: $\\lambda^*_i c_i(x^*) = 0$ ($i \\in \\mathcal{I}$)$\\\\\n(Theorem 12.1, p. 321)\n\n**Description:** Generalizes Lagrange multiplier method to inequalities. First-order necessary conditions for local optimality under CQ. Equivalent to $\\nabla_x \\mathcal{L}(x^*, \\lambda^*) = 0$, feasibility, and complementarity.\n\n**Goal:** Characterize candidate local minimizers via a system of equations and inequalities.\n**Applications:** Optimality certification, Algorithm termination (e.g., SQP, IPM), Duality theory\n**Methods:** Solve $\\nabla_x \\mathcal{L} = 0$, $\\lambda_i c_i = 0$, $\\lambda_i \\ge 0$, $c_i \\ge 0$, Newton-type methods on KKT system\n**Examples:** QP: solve $Q x - b = C^T \\lambda$, $\\lambda \\ge 0$, $\\lambda \\circ (C x - d) = 0$"
  },
  {
    "front": "ðŸ§© Lagrangian Function ($\\mathcal{L}(x, \\lambda)$)\nðŸ“˜ Domain: Constrained Optimization Theory",
    "back": "**Definition:** $\\mathcal{L}(x, \\lambda) = f(x) - \\sum_{i \\in \\mathcal{E}} \\lambda_i c_i(x) - \\sum_{i \\in \\mathcal{I}} \\lambda_i c_i(x)$\n\n**Description:** Combines objective and constraints into a single function. KKT stationarity is $\\nabla_x \\mathcal{L}(x^*, \\lambda^*) = 0$. For equality-only: $\\mathcal{L}(x, \\lambda) = f(x) - \\lambda^T c(x)$\n\n**Goal:** Convert constrained problem into unconstrained saddle-point problem.\n**Applications:** KKT derivation, Duality, SQP methods\n**Methods:** Form $\\mathcal{L}$, set $\\nabla_x \\mathcal{L} = 0$, Dual function: $q(\\lambda) = \\inf_x \\mathcal{L}(x, \\lambda)$\n**Examples:** Eigenvalue: $\\mathcal{L}(x, \\lambda) = x^T Q x - \\lambda (x^T x - 1)$"
  },
  {
    "front": "ðŸ§© Tangent Cone ($T_\\Omega(x)$)\nðŸ“˜ Domain: Constrained Optimization Geometry",
    "back": "**Definition:** The set of directions $d$ such that there exists a sequence $x_k \\in \\Omega$, $x_k \\to x$, and $t_k \\downarrow 0$ with $(x_k - x)/t_k \\to d$.\n\n**Description:** Limit of feasible directions from $x$. Contains all $d$ for which a feasible path exists in $\\Omega$. Under LICQ, $T_\\Omega(x) = \\mathcal{F}(x)$ (linearized cone).\n\n**Goal:** Describe local geometry of feasible set at $x$.\n**Applications:** First-order necessary conditions (Theorem 12.3), Convergence analysis\n**Methods:** \n**Examples:** Equality $c(x)=0$: $T_\\Omega(x) = \\ker \\nabla c(x)^T$, Inequality at boundary: half-space tangent"
  },
  {
    "front": "ðŸ§© Linear Independence Constraint Qualification (LICQ)\nðŸ“˜ Domain: Constrained Optimization Theory",
    "back": "**Definition:** At $x \\in \\Omega$, the gradients $\\{\\nabla c_i(x) \\mid i \\in \\mathcal{A}(x)\\}$ are linearly independent.\n\n**Description:** Strong CQ ensuring KKT multipliers are unique and $T_\\Omega(x) = \\mathcal{F}(x)$. Prevents degenerate constraint configurations.\n\n**Goal:** Ensure well-posedness of KKT system and geometric regularity.\n**Applications:** Guarantee KKT necessity, Uniqueness of $\\lambda^*$\n**Methods:** Check rank of Jacobian of active constraints = |$\\mathcal{A}(x)$|\n**Examples:** Holds for $x^T x = 1$, $x \\ne 0$"
  },
  {
    "front": "ðŸ§© Active Set of Indices ($\\mathcal{A}(x)$)\nðŸ“˜ Domain: Constrained Optimization",
    "back": "**Definition:** $\\mathcal{A}(x) = \\mathcal{E} \\cup \\{i \\in \\mathcal{I} \\mid c_i(x) = 0\\}$ â€” indices of binding constraints at $x$.\n\n**Description:** Determines which constraints are active (tight). Only these affect local geometry and KKT conditions.\n\n**Goal:** Identify binding constraints for local analysis.\n**Applications:** LICQ check, Active-set algorithms, Reduced KKT system\n**Methods:** \n**Examples:** "
  },
  {
    "front": "ðŸ§© Farkas' Lemma\nðŸ“˜ Domain: Convex Analysis / Linear Algebra",
    "back": "**Definition:** For $A \\in \\mathbb{R}^{m \\times n}$, $b \\in \\mathbb{R}^m$, exactly one holds:\\n1. $\\exists x \\ge 0$ s.t. $A x = b$\\\\\n2. $\\exists y$ s.t. $A^T y \\ge 0$, $b^T y < 0$\n\n**Description:** Fundamental result in conic duality. Used to prove KKT: if $-\\nabla f(x) \\notin \\mathcal{K}$ (cone of active gradients), then descent direction exists.\n\n**Goal:** Prove impossibility of infeasibility via separating hyperplane.\n**Applications:** Proof of KKT (via cone separation), LP duality, Support vector machines\n**Methods:** Geometric: separating hyperplane, Algebraic: Gordan, Motzkin theorems\n**Examples:** "
  },
  {
    "front": "ðŸ§© Linear Program (LP) in Standard Form (64)\nðŸ“˜ Domain: Linear Programming",
    "back": "**Definition:** The problem of minimizing a cost function $f(x)=c^{T}x$ subject to linear equality constraints $Ax=b$ and non-negativity constraints $x\\ge0$.\n\n**Description:** This is the formulation assumed when applying the Simplex method. It requires conversion tricks (e.g., slack variables) if the original problem contains inequalities. Typically assumes $m<n$ and $A$ has full row rank (linearly independent rows).\n\n**Goal:** Minimize linear cost over polyhedral feasible set.\n**Applications:** Resource allocation, production planning, logistics\n**Methods:** Simplex Method, Interior Point Methods\n**Examples:** "
  },
  {
    "front": "ðŸ§© Linear Program (LP) in Canonical Form (65)\nðŸ“˜ Domain: Linear Programming",
    "back": "**Definition:** The problem of minimizing $c^{T}x$ subject to inequality constraints $Ax\\le b$ and non-negativity constraints $x\\ge0$.\n\n**Description:** This form represents the feasible region $\\Omega$ as a polyhedron (polygon when $n=2$). It is convertible to standard form (64) using slack variables.\n\n**Goal:** Minimize linear objective over inequality-constrained domain.\n**Applications:** Initial formulation of real-world LP problems\n**Methods:** Add slack variables: $$ Ax + z = b $$, $$ z \\ge 0 $$ â†’ standard form (66)\n**Examples:** "
  },
  {
    "front": "ðŸ§© Simplex Method\nðŸ“˜ Domain: Linear Programming",
    "back": "**Definition:** A descent method for solving LP problems in standard form by starting at a vertex of the feasible region and moving along edges to adjacent vertices where the cost strictly decreases.\n\n**Description:** The method guarantees convergence to the global minimizer (assuming non-degeneracy) because the cost decreases at each pivot and no vertex is revisited. It was devised by George Dantzig in the 1940s.\n\n**Goal:** Find global minimum of linear program.\n**Applications:** Solving LPs in standard form (64)\n**Methods:** Phase I: Find initial basic feasible solution, Phase II: Pivot to reduce cost until optimality ($$ s \\ge 0 $$), Use reduced costs $$ s_j = c_j - \\lambda^T A_{:j} $$ to select entering variable\n**Examples:** "
  },
  {
    "front": "ðŸ§© Basic Feasible Solution (Vertex)\nðŸ“˜ Domain: Linear Programming",
    "back": "**Definition:** A solution $x$ to $Ax=b$ in standard form such that $x\\ge0$ and exactly $n-m$ components are zero (assuming full row rank of $A$).\n\n**Description:** These points correspond to the vertices of the feasible polyhedron. The Simplex method moves exclusively between such points.\n\n**Goal:** Serve as endpoints for descent steps along feasible edges.\n**Applications:** Starting point for Simplex Phase II (if $B^{-1}b \\ge 0$)\n**Methods:** \n**Examples:** For problem (67), initial vertex: $x_{1}=8$, $x_{2}=9$ (basic), $x_{3}=x_{4}=x_{5}=0$ (non-basic)."
  },
  {
    "front": "ðŸ§© Minimum Ratio Rule\nðŸ“˜ Domain: Simplex Method",
    "back": "**Definition:** The rule to determine the leaving basic variable by computing $\\theta^* = \\min\\left\\{\\frac{(B^{-1}b)_{i}}{(B^{-1}u)_{i}} \\mid (B^{-1}u)_{i} > 0\\right\\}$, where $u$ is the column of the entering variable in $N$.\n\n**Description:** This rule ensures the step size along the edge is maximal while preserving feasibility, identifying the next vertex.\n\n**Goal:** Determine the leaving variable and step size to the next vertex.\n**Applications:** Step 3 of the Simplex Method\n**Methods:** Compute ratios $\\frac{(B^{-1}b)_{i}}{(B^{-1}u)_{i}}$ only for $i$ where $(B^{-1}u)_{i} > 0$.\n**Examples:** In example (67), ratios $\\frac{8}{2}=4$ and $\\frac{9}{3}=3$; minimum is 3, so $x_{2}$ leaves."
  },
  {
    "front": "ðŸ§© Critical Cone ($\\mathcal{C}(x^{*},\\lambda^{*})$)\nðŸ“˜ Domain: Constrained Optimization Theory",
    "back": "**Definition:** The set of directions $w\\in\\mathbb{R}^{n}$ such that $\\nabla c_{i}(x^{*})^{T}w = 0$ for all active constraints $i$ (i.e., $c_{i}(x^{*})=0$ and $\\lambda^{*}_{i}>0$), and $\\nabla c_{i}(x^{*})^{T}w \\ge 0$ for active constraints with $\\lambda^{*}_{i}=0$.\n\n**Description:** Used to restrict second-order necessary/sufficient conditions at a KKT point. For the eigenvalue problem $\\min x^{T}Qx$ s.t. $\\|x\\|=1$, it is the tangent plane $\\{w \\mid x^{*T}w=0\\}$.\n\n**Goal:** Define the subspace on which the Hessian of the Lagrangian must be positive semidefinite (second-order conditions).\n**Applications:** Second-Order Necessary Conditions (Theorem 12.5)\n**Methods:** \n**Examples:** For constraint $c(x) = \\|x\\|^2 - 1 = 0$, $\\mathcal{C}(x^{*},\\lambda^{*}) = \\{w \\mid x^{*T}w = 0\\}$."
  },
  {
    "front": "ðŸ§© Second Order Necessary Condition (Eigenvalue Problem)\nðŸ“˜ Domain: Constrained Optimization Theory",
    "back": "**Definition:** At a local minimizer $x^{*}$ of $\\min x^{T}Qx$ s.t. $\\|x\\|=1$, the restricted Hessian satisfies $w^{T}(Q - \\lambda^{*}I)w \\ge 0$ for all $w \\in \\mathcal{C}(x^{*},\\lambda^{*}) = \\{w \\mid x^{*T}w=0\\}$.\n\n**Description:** Equivalent to $\\lambda^{*}$ being the smallest eigenvalue of $Q$. If $\\lambda^{*}$ is not the smallest, $x^{*}$ cannot be a local minimizer.\n\n**Goal:** Verify whether a KKT point $x^{*}$ (unit eigenvector) is a local minimizer.\n**Applications:** Analyzing constrained eigenvalue problems\n**Methods:** Check if $\\lambda^{*}$ is the smallest eigenvalue of $Q$.\n**Examples:** If $\\lambda^{*}$ is the smallest eigenvalue and multiplicity one, $x^{*}$ is a local minimizer."
  },
  {
    "front": "ðŸ§© Duality Theory (Convex)\nðŸ“˜ Domain: Convex Optimization",
    "back": "**Definition:** A framework for analyzing the primal problem $\\min~f(x)$ s.t. $c(x)\\ge0$ via the Lagrangian and dual problem, valid under convexity assumptions on $f$ and concavity on $c_j$.\n\n**Description:** Requires $f$ convex and $c_j$ concave so that the Lagrangian $\\mathcal{L}(x,\\lambda) = f(x) - \\lambda^{T}c(x)$ is convex in $x$ for fixed $\\lambda\\ge0$. Enables weak/strong duality results.\n\n**Goal:** Analyze and solve constrained convex optimization problems using dual variables.\n**Applications:** Linear Programming, Quadratic Programming\n**Methods:** Form Lagrangian $\\mathcal{L}(x,\\lambda)=f(x)-\\lambda^{T}c(x)$\n**Examples:** "
  },
  {
    "front": "ðŸ§© Quadratic Function (Optimization Tool)\nðŸ“˜ Domain: Optimization",
    "back": "**Definition:** A simple function structure used as a tool to model objective functions, even if the original function is not quadratic.\n\n**Description:** Quadratic functions appear in many applications and are useful for analyzing algorithm behavior, such as the speed of convergence of the steepest descent method. They are employed in both unconstrained and constrained optimization contexts, often replacing the original function via Taylor approximation.\n\n**Goal:** Simplify analysis and serve as an approximation model for non-quadratic functions\n**Applications:** Unconstrained optimization, Constrained optimization, Analyzing Steepest Descent speed\n**Methods:** Approximating original function via Taylor's theorem\n**Examples:** Solving the linear system $Qx=b$ where $\\nabla^2 f(x)=Q$"
  },
  {
    "front": "ðŸ§© Descent Direction Condition\nðŸ“˜ Domain: Unconstrained Optimization, Line Search Methods",
    "back": "**Definition:** The algebraic condition required for a direction $p_{k}$ to ensure the objective function $f$ decreases when moving from $x_{k}$ into $p_{k}$, given by $\\nabla f(x_{k})^{T}p_{k}<0$.\n\n**Description:** This condition ensures that the derivative of the one-dimensional function $\\phi(\\alpha)=f(x_{k}+\\alpha p_{k})$ evaluated at $\\alpha=0$ is negative, confirming an initial decrease in $f$. It is based on the first degree Taylor's polynomial.\n\n**Goal:** Ensure progress towards a minimizer in Line Search Methods\n**Applications:** Choosing $p_k$ in Line Search methods\n**Methods:** Using the chain rule to find $\\phi^{\\prime}(0)$\n**Examples:** "
  },
  {
    "front": "ðŸ§© Direction of Steepest Descent\nðŸ“˜ Domain: Unconstrained Optimization, Line Search Methods",
    "back": "**Definition:** The choice of descent direction $p_{k}=-\\nabla f(x_{k})$, which yields the largest decrease in $f$ locally from $x_{k}$ for small $\\alpha>0$.\n\n**Description:** This is the simplest and cheapest method for choosing a descent direction, equivalent to setting $B_k=I$ in the generalized direction formula (11). Despite appearing to be the 'best choice' based on local decrease, it can suffer from slow linear convergence, especially if the objective function's condition number is large.\n\n**Goal:** Choose the fastest local rate of descent\n**Applications:** Steepest Descent Method\n**Methods:** Setting $p_k = -\\nabla f(x_k)$\n**Examples:** "
  },
  {
    "front": "ðŸ§© Newton's Method (Optimization)\nðŸ“˜ Domain: Unconstrained Optimization",
    "back": "**Definition:** A method for finding a stationary point $x^{*}$ by applying the standard Newton's method to solve the nonlinear system $\\nabla f(x)=0$, resulting in the iterative update $x_{k+1}=x_{k}-(\\nabla^{2}f(x_{k}))^{-1}\\nabla f(x_{k})$.\n\n**Description:** In the context of line search, this corresponds to using the Hessian $B_{k}=\\nabla^{2}f(x_{k})$ as the approximating matrix and setting the step length $\\alpha=1$ at every step, which is a notable advantage. It replaces the objective function $f$ with a simple quadratic function and, when close to the solution, exhibits rapid quadratic convergence.\n\n**Goal:** Find stationary points rapidly\n**Applications:** Small dimensional optimization problems\n**Methods:** Uses $B_k = \\nabla^2 f(x_k)$, Sets $\\alpha=1$\n**Examples:** $min(x_{1}-2)^{4}+(x_{1}-2x_{2})^{2}$"
  },
  {
    "front": "ðŸ§© Steepest Descent Method\nðŸ“˜ Domain: Unconstrained Optimization",
    "back": "**Definition:** An iterative Line Search Method that consistently uses the Direction of Steepest Descent ($p_k = -\\nabla f(x_k)$) for its search direction, corresponding to setting $B_{k}=I$ in the generalized direction formula (11).\n\n**Description:** This method is computationally cheap because it avoids forming or inverting the Hessian. However, its convergence speed is typically linear, and if the condition number of the Hessian approximation $Q$ is large, convergence can be extremely slow.\n\n**Goal:** Iteratively minimize $f$ with minimal computational cost per step\n**Applications:** Used when $n$ is large and Hessian computation is too expensive\n**Methods:** Using exact step length $\\alpha_{k}$ derived from quadratic model\n**Examples:** "
  },
  {
    "front": "ðŸ§© Condition Number (\\kappa(Q))\nðŸ“˜ Domain: Numerical Analysis, Optimization",
    "back": "**Definition:** The ratio of the largest eigenvalue ($\\lambda_n$) to the smallest eigenvalue ($\\lambda_1$) of the matrix $Q$, defined as $\\kappa(Q) = \\frac{\\lambda_n}{\\lambda_1}$, used to analyze the convergence rate of iterative methods.\n\n**Description:** For the Steepest Descent method applied to a quadratic function, the condition number dictates the linear convergence rate, $C=\\frac{\\kappa(Q)-1}{\\kappa(Q)+1}$. A large condition number means $C$ is close to 1, indicating very slow convergence, requiring thousands of steps to reach an approximation.\n\n**Goal:** Quantify the geometry of the function's contours and predict convergence speed\n**Applications:** Analysis of Steepest Descent Method\n**Methods:** Calculation using eigenvalues of Q\n**Examples:** If $\\kappa(Q)=800$, $C=0.9975$"
  },
  {
    "front": "ðŸ§© Quasi-Newton Methods\nðŸ“˜ Domain: Unconstrained Optimization",
    "back": "**Definition:** A family of iterative methods aimed at inexpensively producing a matrix $B_{k}$ that approximates the Hessian matrix $\\nabla^{2}f(x_{k})$, used to compute the descent direction $p_{k}=-B_{k}^{-1}\\nabla f(x_{k})$.\n\n**Description:** These methods are used when forming and solving the full Hessian system (12) is too time-consuming, typically aiming for superlinear convergence ($1<p<2$)â€”a speed that is faster than linear but usually slower than quadratic. They rely on small rank-updates to improve the approximation iteratively.\n\n**Goal:** Achieve fast convergence without the expense of calculating the full Hessian\n**Applications:** Unconstrained minimization when $n$ is large\n**Methods:** Rank-updating schemes ($B_{k+1}=B_{k}+F_{k}$ with $rank(F_k)\\le 2$)\n**Examples:** SR1 method, BFGS method"
  },
  {
    "front": "ðŸ§© Secant Condition\nðŸ“˜ Domain: Quasi-Newton Methods",
    "back": "**Definition:** A condition used to define the updated Hessian approximation $B_{k+1}$ in Quasi-Newton methods, derived from the first-degree Taylor approximation of $\\nabla f$ and requiring $B_{k+1}(x_{k+1}-x_{k})=\\nabla f(x_{k+1})-\\nabla f(x_{k})$.\n\n**Description:** This condition dictates how the updated matrix $B_{k+1}$ must relate the change in position ($s_k = x_{k+1}-x_{k}$) to the change in gradient ($y_k = \\nabla f(x_{k+1})-\\nabla f(x_{k})$). It is a finite difference approximation of the relationship between the Hessian and the gradient changes.\n\n**Goal:** Provide a relationship to constrain the rank-update formula $F_k$\n**Applications:** Deriving SR1 update, Deriving BFGS method\n**Methods:** Using Taylor's polynomial of $\\nabla f$"
  },
  {
    "front": "ðŸ§© SR1 Update\nðŸ“˜ Domain: Quasi-Newton Methods",
    "back": "**Definition:** The symmetric rank-one (SR1) update formula used to incrementally modify the Hessian approximation $B_{k}$ using a rank-one matrix update to satisfy the secant condition (17).\n\n**Description:** It is the simplest rank-update scheme, defined by $B_{k+1}=B_{k}+\\frac{1}{(y_{k}-B_{k}s_{k})^{T}s_{k}}(y_{k}-B_{k}s_{k})(y_{k}-B_{k}s_{k})^{T}$. This update can fail if the denominator is zero or very small, in which case the matrix $B_k$ is usually left unchanged.\n\n**Goal:** Update the Hessian approximation inexpensively while retaining symmetry\n**Applications:** Quasi-Newton Methods\n**Methods:** Enforcing $B_{k+1}$ symmetry, Satisfying the Secant Condition"
  },
  {
    "front": "ðŸ§© Bisection Method (Step Length)\nðŸ“˜ Domain: Numerical Optimization, Line Search Methods",
    "back": "**Definition:** A basic algorithm for finding a zero of a continuous, univariate function, specifically applied here to find $\\alpha_{k}$ by locating a zero of $\\phi^{\\prime}(\\alpha)=\\nabla f(x_{k}+\\alpha p_{k})^{T}p_{k}$.\n\n**Description:** The method iteratively halves an interval $[0, \\hat{\\alpha}]$ that is known to contain a zero of $\\phi^{\\prime}$ because $\\phi^{\\prime}$ changes sign across the interval. Since $\\phi^{\\prime}(0)<0$, it requires guessing a point $\\hat{\\alpha}>0$ such that $\\phi^{\\prime}(\\hat{\\alpha})>0$.\n\n**Goal:** Find an approximate optimal step length $\\alpha_{k}$ for the 1D subproblem (7)\n**Applications:** Univariate zero finding\n**Methods:** Requires only function evaluations (no derivatives), Halving the search interval\n**Examples:** Example with $\\phi^{\\prime}(\\alpha)=\\alpha^{6}-\\alpha-1$"
  },
  {
    "front": "ðŸ§© Nonlinear Least Squares Problems\nðŸ“˜ Domain: Optimization, Data Fitting",
    "back": "**Definition:** Structured unconstrained optimization problems that arise when minimizing the sum of squares of $m$ residual functions $r_{j}(x)$, where $r_{j}:\\mathbb{R}^{n}\\rightarrow\\mathbb{R}$ are smooth functions, often under the assumption $m\\ge n$.\n\n**Description:** These problems frequently appear when tuning a model to achieve the best fit for given data, such as in machine learning or neural network applications. Due to their structure, simplifying tricks can be applied, particularly when combined with Line Search and Quasi-Newton methods.\n\n**Goal:** Find parameters $x$ that minimize the residual errors between a model and observed data\n**Applications:** Machine learning, Neural network applications, Model tuning\n**Methods:** Structured Quasi-Newton methods"
  },
  {
    "front": "ðŸ§© Trust Region Methods (TRMs)\nðŸ“˜ Domain: Unconstrained Optimization",
    "back": "**Definition:** An iterative method for solving unconstrained optimization problems $\\min f(x)$ by solving a sequence of constrained quadratic subproblems within a trust region around the current iterate $x_k$.\n\n**Description:** At each iteration, a step $p_k$ is computed by minimizing a quadratic model $m_k(p)$ of $f(x_k + p)$ subject to $\\|p\\| \\le \\Delta_k$. The radius $\\Delta_k$ is adjusted based on how well the model predicts the actual function decrease.\n\n**Goal:** Find a local minimizer of $f(x)$ with robust global convergence properties.\n**Applications:** Large-scale nonlinear optimization, Non-convex problems where line search may fail\n**Methods:** Solve Trust Region Subproblem (52) at each $x_k$, Use KKT conditions to characterize optimal $p_k$, Update $\\Delta_k$ using comparison ratio $\\rho_k$\n**Examples:** "
  },
  {
    "front": "ðŸ§© Trust Region Subproblem (52)\nðŸ“˜ Domain: Trust Region Methods",
    "back": "**Definition:** $\\min_{p \\in \\mathbb{R}^n} m_k(p) \\quad \\text{subject to} \\quad \\|p\\| \\le \\Delta_k$, where $m_k(p) = f_k + g_k^T p + \\frac{1}{2} p^T B_k p$.\n\n**Description:** Core subproblem solved at each TRM iteration. The solution $p_k$ satisfies $(B_k + \\lambda I)p_k = -g_k$, $\\lambda \\ge 0$, $\\lambda(\\|p_k\\| - \\Delta_k) = 0$, and $B_k + \\lambda I \\succeq 0$.\n\n**Goal:** Compute a step $p_k$ that sufficiently reduces the model within the trust region.\n**Applications:** Step generation in TRM\n**Methods:** Case 1 (interior): $\\lambda = 0$, solve $B_k p = -g_k$ if $\\|p\\| \\le \\Delta_k$, Case 2 (boundary): solve $(B_k + \\lambda I)p = -g_k$, $\\|p\\| = \\Delta_k$ via root-finding in $\\lambda$, Approximate via Krylov subspace methods\n**Examples:** "
  },
  {
    "front": "ðŸ§© Model Function ($m_k(p)$)\nðŸ“˜ Domain: Trust Region Methods",
    "back": "**Definition:** Second-order Taylor expansion of $f$ around $x_k$: $m_k(p) = f(x_k) + \\nabla f(x_k)^T p + \\frac{1}{2} p^T B_k p$, where $B_k \\approx \\nabla^2 f(x_k)$.\n\n**Description:** Local surrogate for $f$. When $B_k = \\nabla^2 f(x_k)$, the approximation error satisfies $|f(x_k + p) - m_k(p)| = O(\\|p\\|^3)$.\n\n**Goal:** Provide a tractable local model for minimization within the trust region.\n**Applications:** Defining Trust Region Subproblem (52)\n**Methods:** \n**Examples:** "
  },
  {
    "front": "ðŸ§© Comparison Ratio ($\\rho_k$)\nðŸ“˜ Domain: Trust Region Methods",
    "back": "**Definition:** $\\rho_k = \\frac{f(x_k) - f(x_k + p_k)}{m_k(0) - m_k(p_k)}$ â€” ratio of actual to predicted reduction.\n\n**Description:** Measures model quality. If $\\rho_k \\ge \\eta_1 > 0$ (e.g., 0.1), accept step and possibly increase $\\Delta_k$. If $\\rho_k < \\eta_1$, reject step and shrink $\\Delta_k$.\n\n**Goal:** Assess reliability of quadratic model $m_k$ to control trust region radius.\n**Applications:** Step acceptance/rejection, Adaptive radius update\n**Methods:** Accept if $\\rho_k \\ge 0.1$, increase $\\Delta_k$ if $\\rho_k \\ge 0.75$, Reject and shrink $\\Delta_k$ if $\\rho_k < 0.1$\n**Examples:** "
  },
  {
    "front": "ðŸ§© Krylov Subspace Approximation (TR Subproblem)\nðŸ“˜ Domain: Trust Region Subproblem Solving",
    "back": "**Definition:** Approximate solution of the TR subproblem by restricting $p$ to a low-dimensional Krylov subspace $\\mathcal{K}_j = \\operatorname{span}\\{g_k, B_k^{-1}g_k, \\ldots, (B_k^{-1})^{j-1}g_k\\}$.\n\n**Description:** For $j=2$, reduces to 2D problem in $\\operatorname{span}\\{g_k, B_k^{-1}g_k\\}$. Fast and effective when $B_k$ is large/sparse. Equivalent to CG steps on the Newton system.\n\n**Goal:** Solve TR subproblem approximately when exact solution is costly.\n**Applications:** Large-scale TRMs\n**Methods:** Project subproblem onto $\\mathcal{K}_j$, Solve reduced 2D TR subproblem in $(\\alpha, \\beta)$, Use Steihaug-Toint truncated CG\n**Examples:** "
  },
  {
    "front": "ðŸ§© Lagrangian for TR Subproblem ($\\mathcal{L}(p,\\lambda)$)\nðŸ“˜ Domain: Trust Region Methods",
    "back": "**Definition:** $\\mathcal{L}(p, \\lambda) = m_k(p) + \\lambda (\\|p\\|^2 - \\Delta_k^2)$, where constraint $g(p) = \\Delta_k^2 - \\|p\\|^2 \\ge 0$.\n\n**Description:** Used to derive KKT conditions: $\\nabla_p \\mathcal{L} = g_k + B_k p + 2\\lambda p = 0$, $\\lambda \\ge 0$, $\\lambda(\\|p\\|^2 - \\Delta_k^2) = 0$, $B_k + 2\\lambda I \\succeq 0$.\n\n**Goal:** Formulate optimality conditions for the TR subproblem.\n**Applications:** Deriving $(B_k + \\lambda I)p = -g_k$ with $\\lambda \\ge 0$\n**Methods:** Stationarity: $g_k + (B_k + 2\\lambda I)p = 0$, Complementary slackness and dual feasibility\n**Examples:** "
  },
  {
    "front": "ðŸ§© Krylov Subspace Approximation (TRM)\nðŸ“˜ Domain: Trust Region Methods",
    "back": "**Definition:** A technique to approximately solve the Trust Region Subproblem (52) by restricting the step $$ p $$ to a low-dimensional Krylov subspace, typically $$ \\operatorname{span}\\{q, B^{-1}q\\} $$, reducing the problem to a 2D constrained optimization.\n\n**Description:** Instead of solving the full $$ n $$-dimensional quadratic subproblem exactly, it solves a reduced 2D problem in coefficients $$ (\\alpha, \\beta) $$ using an orthonormal basis $$ \\{\\hat{q}, \\tilde{q}\\} $$ of the subspace (58). This is equivalent to a 2-step Krylov method for the linear system (54).\n\n**Goal:** Efficiently approximate the solution to the Trust Region Subproblem (52).\n**Applications:** Step computation in Trust Region Methods when $$ n $$ is large\n**Methods:** Construct $$ p = [\\hat{q}, \\tilde{q}] \\begin{bmatrix} \\alpha \\\\ \\beta \\end{bmatrix} $$ with orthonormal basis of $$ \\operatorname{span}\\{q, B^{-1}q\\} $$ (58)., Minimize reduced quadratic model subject to $$ \\|[\\alpha, \\beta]^T\\| \\le \\Delta_k $$., Extend to higher-order Krylov: $$ \\operatorname{span}\\{q, B^{-1}q, \\ldots, (B^{-1})^j q\\} $$ for small $$ j $$.\n**Examples:** "
  },
  {
    "front": "ðŸ§© Second Order Necessary Conditions (Constrained)\nðŸ“˜ Domain: Constrained Optimization Theory",
    "back": "**Definition:** At a local minimizer $$ x^* $$ with Lagrange multipliers $$ \\lambda^* $$, the Hessian of the Lagrangian must satisfy $$ w^T \\nabla_{xx}^2 \\mathcal{L}(x^*, \\lambda^*) w \\ge 0 $$ for all $$ w \\in \\mathcal{C}(x^*, \\lambda^*) $$ (Theorem 12.5, p. 332).\n\n**Description:** This is a necessary condition for local optimality. It applies only on the critical cone â€” directions where the linearized constraints are satisfied and the reduced gradient vanishes.\n\n**Goal:** Verify whether a KKT point $$ x^* $$ can be a local minimizer.\n**Applications:** Classification of stationary points\n**Methods:** Evaluate quadratic form $$ w^T \\nabla_{xx}^2 \\mathcal{L}(x^*, \\lambda^*) w $$ on $$ \\mathcal{C}(x^*, \\lambda^*) $$, For 1D active constraint: check second derivative along feasible arc\n**Examples:** "
  },
  {
    "front": "ðŸ§© Second Order Sufficient Conditions (Constrained)\nðŸ“˜ Domain: Constrained Optimization Theory",
    "back": "**Definition:** If $$ x^* $$ is a KKT point and $$ w^T \\nabla_{xx}^2 \\mathcal{L}(x^*, \\lambda^*) w > 0 $$ for all $$ w \\in \\mathcal{C}(x^*, \\lambda^*) $$, $$ w \\ne 0 $$, then $$ x^* $$ is a strict local minimizer (Theorem 12.6, p. 333).\n\n**Description:** Stronger than necessary conditions, this guarantees local optimality when the Lagrangian Hessian is positive definite on the critical cone.\n\n**Goal:** Confirm that a KKT point $$ x^* $$ is a strict local minimizer.\n**Applications:** Proving local optimality in constrained problems\n**Methods:** Verify positive definiteness of $$ \\nabla_{xx}^2 \\mathcal{L} $$ on $$ \\mathcal{C}(x^*, \\lambda^*) $$, For linear constraints: check $$ \\nabla^2 f(x^*) \\succ 0 $$ on null space of active constraints\n**Examples:** In example (29), point $$ (-1,-1) $$ with $$ \\lambda^* = 1/2 $$ has positive definite $$ \\nabla_{xx}^2 \\mathcal{L} $$ on critical cone â†’ local minimizer."
  },
  {
    "front": "ðŸ§© Critical Cone ($$ \\mathcal{C}(x^*, \\lambda^*) $$)\nðŸ“˜ Domain: Constrained Optimization Geometry",
    "back": "**Definition:** The set of directions $$ w $$ such that:\n1. $$ w $$ is in the linearized feasible cone: $$ \\nabla c_i(x^*)^T w \\ge 0 $$ for all $$ i $$ with $$ c_i(x^*)=0 $$,\n2. $$ \\nabla f(x^*)^T w = 0 $$ (critical directions).\n\n**Description:** Subset of the feasible direction cone $$ \\mathcal{F}(x^*) $$ where first-order improvement is zero. Second-order conditions are checked only on this cone. For equality constraints, it is the null space of $$ \\nabla c(x^*)^T $$.\n\n**Goal:** Define the subspace for second-order optimality tests.\n**Applications:** Second-order necessary/sufficient conditions\n**Methods:** Active inequalities with $$ \\lambda_i^* > 0 $$: $$ w \\perp \\nabla c_i(x^*) $$, Active inequalities with $$ \\lambda_i^* = 0 $$: $$ \\nabla c_i(x^*)^T w \\ge 0 $$, Equality constraints: $$ \\nabla c_i(x^*)^T w = 0 $$\n**Examples:** Example 12.7 (59) at $$ (0,0) $$: $$ \\mathcal{C} = \\{(0, w_2) \\mid w_2 \\ge 0\\} $$"
  },
  {
    "front": "ðŸ§© Slack Variables ($$ z $$)\nðŸ“˜ Domain: Linear Programming",
    "back": "**Definition:** Non-negative variables $$ z \\ge 0 $$ introduced to convert inequalities $$ Ax \\le b $$ into equalities $$ Ax + z = b $$.\n\n**Description:** Each inequality gets one slack variable. Transforms canonical form into standard form suitable for Simplex Method.\n\n**Goal:** Enable equality-based algorithms on inequality-constrained LPs.\n**Applications:** Conversion from canonical to standard form\n**Methods:** Augment constraint matrix: $$ [A \\ I] $$, variable vector: $$ [x; z] $$\n**Examples:** "
  },
  {
    "front": "ðŸ§© Continuous Optimization\nðŸ“˜ Domain: Optimization",
    "back": "**Definition:** Formulating a problem mathematically such that the objective function $f: \\mathbb{R}^{n}\\rightarrow\\mathbb{R}$ and the constraints $c_{i}:\\mathbb{R}^{n}\\rightarrow\\mathbb{R}$ are considered over the continuous space $\\mathbb{R}^{n}$\n\n**Description:** The dimension $n$ and the number of constraints can be large. It contrasts with discrete optimization, where $\\mathbb{R}^{n}$ is replaced by a discrete set.\n\n**Goal:** Consider problem (1.1) on p. 3\n**Applications:** \n**Methods:** Smooth optimization (using partial derivatives and gradients)\n**Examples:** "
  },
  {
    "front": "ðŸ§© Objective Function ($f$)\nðŸ“˜ Domain: Optimization",
    "back": "**Definition:** The function $f: \\mathbb{R}^{n}\\rightarrow\\mathbb{R}$ that results from modeling or is given in an optimization problem.\n\n**Description:** The objective function is the quantity that is minimized (or maximized, by minimizing $-f$). Its gradient ($\\nabla f$) indicates the directions in which $f$ decreases.\n\n**Goal:** To be minimized or maximized\n**Applications:** \n**Methods:** \n**Examples:** $f(x_{1},x_{2})=x_{1}^{4}+x_{2}^{6}$"
  },
  {
    "front": "ðŸ§© Gradient (\\nabla f)\nðŸ“˜ Domain: Optimization, Calculus",
    "back": "**Definition:** The gradient of $f$, denoted $\\nabla f$, which provides information about the local behavior of the function.\n\n**Description:** It appears often in computations, especially in smooth optimization, because it tells in which directions the function $f$ decreases. At a point $x$ on a level set $L_c(f)$, $\\nabla f(x)$ is orthogonal against the tangent plane of the level set.\n\n**Goal:** Determine direction of function decrease\n**Applications:** Smooth optimization computations, Finding tangent planes/lines\n**Methods:** Computing partial derivatives\n**Examples:** $\\nabla f(x)=[4x_{1}^{3}, 6x_{2}^{5}]^T$ for $f(x_{1},x_{2})=x_{1}^{4}+x_{2}^{6}$"
  },
  {
    "front": "ðŸ§© Level Set ($L_c(f)$)\nðŸ“˜ Domain: Optimization, Calculus",
    "back": "**Definition:** The set of points $x \\in \\mathbb{R}^n$ where the function $f$ takes a constant value $c$, defined as $L_c(f) = \\{ x \\in \\mathbb{R}^n \\mid f(x) = c \\}$.\n\n**Description:** These sets are typically of dimension $n-1$. When $n=2$, they are curves and are frequently referred to as 'contours of $f$'.\n\n**Goal:** Visualize or understand the function's landscape\n**Applications:** Drawing pictures to illustrate mathematics when $n=2$ or 3\n**Methods:** Requires computing the gradient $\\nabla f(x)$ to determine orthogonality to the tangent plane\n**Examples:** "
  },
  {
    "front": "ðŸ§© Convexity\nðŸ“˜ Domain: Optimization",
    "back": "**Definition:** A simplifying property of function $f$ in a convex set $S\\subset\\mathbb{R}^{n}$ where the line segment between any two points of its graph lies on or above the graph.\n\n**Description:** If $f$ is smooth, convexity is equivalent to having a positive semi-definite Hessian matrix everywhere in $S$, meaning the graph of $f$ is 'bowl-like' everywhere. Convexity makes problem solving easier.\n\n**Goal:** Simplify optimization problem solving\n**Applications:** Convex Optimization\n**Methods:** Checking if the Hessian matrix is positive semi-definite\n**Examples:** $f(x_{1},x_{2})=x_{1}^{4}+x_{2}^{6}$ is convex"
  },
  {
    "front": "ðŸ§© Linear Program (LP)\nðŸ“˜ Domain: Optimization",
    "back": "**Definition:** A type of optimization problem where both the objective function $f$ and the constraints functions $c_{i}$ are linear (plus possibly a constant).\n\n**Description:** Linear programs started modern numerical optimization requiring electronic computers. The feasible set for an LP is always a convex polygon.\n\n**Goal:** Solve optimization problems with strictly linear structures\n**Applications:** Modern numerical optimization\n**Methods:** Algorithms specific to LP (implied by 'LP alone is a vast area')\n**Examples:** Example (1.3 a-d) on p. 4"
  },
  {
    "front": "ðŸ§© Newton's Method\nðŸ“˜ Domain: Numerical Optimization",
    "back": "**Definition:** An iterative method for solving a nonlinear system of equations $r(x)=0$. It computes the next iterate $x_{k+1}$ by solving for the zero of the tangent line approximation of $r(x)$ at $x_k$.\n\n**Description:** For $n=1$, the iterate is $x_{k+1}=x_{k}-\\frac{r(x_{k})}{r^{\\prime}(x_{k})}$. For $n>2$, the derivative is replaced with the Jacobian, $x_{k+1}=x_{k}-J(x_{k})^{-1}r(x_{k})$. This method is important for devising iterative methods for solving optimization problems.\n\n**Goal:** Solve a nonlinear system of equations $r(x)=0$\n**Applications:** Devising iterative methods for optimization problems\n**Methods:** Uses Taylor's theorem, Uses Jacobian $J(x_k)$ (if $n>2$)\n**Examples:** Numerical example (11.31) on p. 281"
  },
  {
    "front": "ðŸ§© Speed of Convergence (Order p)\nðŸ“˜ Domain: Numerical Optimization",
    "back": "**Definition:** A measure used for iterative methods, quantifying how quickly the iterates $x_k$ approach the solution $x$ according to the inequality $||x-x_{k+1}||\\le C||x-x_{k}||^{p}$ for some $C>0$.\n\n**Description:** The order $p$ dictates the rate of convergence. If $p=1$, convergence is linear (requiring $0<C<1$); if $p=2$, convergence is quadratic and is considered fast, often sufficient for very good approximations in just 2-4 iterates.\n\n**Goal:** Measure the effectiveness and efficiency of an iterative algorithm\n**Applications:** Evaluating Optimization Algorithms\n**Methods:** \n**Examples:** Linear ($p=1$), Quadratic ($p=2$), Cubic ($p=3$)"
  }
]